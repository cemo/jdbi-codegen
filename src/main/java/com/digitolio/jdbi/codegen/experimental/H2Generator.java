package com.digitolio.jdbi.codegen.experimental;

import com.digitolio.jdbi.annotations.CodeGen;
import com.digitolio.jdbi.annotations.PK;
import com.digitolio.jdbi.codegen.Scanner;
import com.digitolio.jdbi.strategy.SnakeCaseTranslatingStrategy;
import com.digitolio.jdbi.table.Column;
import com.digitolio.jdbi.table.Table;
import com.digitolio.jdbi.table.TableResolver;
import com.google.common.base.Function;
import com.google.common.base.Joiner;
import com.google.common.base.Strings;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.common.collect.Ordering;
import com.google.common.io.Files;

import javax.annotation.Nullable;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Field;
import java.nio.charset.Charset;
import java.util.*;

/**
 * @author C.Koc
 */
public class H2Generator {

    private final Table table;
    private final Class<?> clazz;
    private final File targetDir;

    public H2Generator(Table table, Class<?> clazz, File targetDir) {
        this.table = table;
        this.clazz = clazz;
        this.targetDir = targetDir;
    }

    public static void main(String[] args) throws IOException {
       String pack = args[0];
       if (Strings.isNullOrEmpty(pack) || pack.contains("OVERWRITE_THIS_VALUE")) {
            return;
        }
        SnakeCaseTranslatingStrategy strategy = new SnakeCaseTranslatingStrategy();
        TableResolver tableResolver = new TableResolver();

//        Set<Class<?>> inputClasses = new Scanner().scanPackage("com.digitolio.jdbi.codegen.test");
        Set<Class<?>> inputClasses = scanPackage(pack);
        List<Class<?>> classes = orderClasses(inputClasses);
        if(classes.isEmpty()) return;
        cleanDirectoryForNewDll(new File(args[1].concat("/db/h2/")));
//        File targetDir = new File("D:\\PersonalProjects\\digitolio\\jdbi-codegen\\src\\main\\java\\cemo");
        File targetDir = new File(args[1]);
        StringBuilder allDdl = new StringBuilder();

        for (Class<?> aClass : classes) {
            Table resolve = tableResolver.resolve(aClass, strategy);
            H2Generator h2Generator = new H2Generator(resolve, aClass, targetDir);
            Object generate = h2Generator.generate();
            String content = generate.toString();
            allDdl.append(content).append("\n\n");
            File file = new File(args[1].concat("/db/h2/").concat(resolve.getTableName().toLowerCase().concat(".ddl")));
            Files.createParentDirs(file);
            BufferedWriter bufferedWriter = Files.newWriter(file, Charset.defaultCharset());
            bufferedWriter.write(content);
            bufferedWriter.close();
        }

        File file = new File(args[1].concat("/db/h2/all-").concat(args[2]).concat(".ddl"));
        Files.createParentDirs(file);
        BufferedWriter bufferedWriter = Files.newWriter(file, Charset.defaultCharset());
        bufferedWriter.write(allDdl.toString());
        bufferedWriter.close();

    }

    @SuppressWarnings({"ConstantConditions", "ResultOfMethodCallIgnored"})
    private static void cleanDirectoryForNewDll(File targetDir) {
        if (targetDir.exists()) {
            for (File file : targetDir.listFiles()) {
                boolean delete = file.delete();
            }
        }
    }

    private static Set<Class<?>> scanPackage(String arg) {
        return new Scanner().scanPackage(arg, CodeGen.DDL_GEN);
    }

    private static List<Class<?>> orderClasses(Set<Class<?>> inputClasses) {
        return Ordering.from(new Comparator<Class>() {
            @Override
            public int compare(Class o1, Class o2) {
                return o1.getSimpleName().compareTo(o2.getSimpleName());
            }
        }).sortedCopy(inputClasses);
    }


    private Object generate() {
        StringBuilder builder = new StringBuilder();
        builder.append("drop table if exists ").append(table.getTableName()).append(";\n");
        builder.append("create table ").append(table.getTableName()).append("(\n");
        int a = 0;

        for (Column column : table.getAllColumns()) {
            builder.append("\t");
            if (a++ > 0) {
                builder.append(",");
            }
            builder.append(column.getDatabaseName())
                   .append(" ")
                   .append(getDbType(column))
                   .append(getNullInfo(column))
                   .append(getDefaultInfo(column))
                   .append(getAutoGeneratedInfo(column))
                   .append("\n");
        }

        builder.append("\t,primary key(");
        List<String> l = Lists.newArrayList();
        for (Column column : table.getPrimaryKeyColumns()) {
            l.add(column.getDatabaseName());
        }
        builder.append(Joiner.on(", ").join(l));
        builder.append(")");

        if(!table.getUniqueIndexes().isEmpty()){
            builder.append("\n\t,");
            builder.append(getUniqueIndexes(table.getUniqueIndexes()));
        }

        if(!table.getIndexes().isEmpty()){
            builder.append("\n\t,");
            builder.append(getIndexes(table.getIndexes()));
        }
        builder.append("\n);");


//        System.out.println(builder.toString());
        return builder.toString();
    }

       //  UNIQUE KEY `NAME_CITYID_UNIQUE` (`CITY_ID`,`NAME`)
   private String getUniqueIndexes(Map<String, List<Column>> uniqueIndexes) {
      List<String> list = Lists.newArrayList();

      for(Map.Entry<String, List<Column>> entry : uniqueIndexes.entrySet()) {
         StringBuilder builder = new StringBuilder();
         builder.append("unique key ").append(entry.getKey()).append(" (");
         ImmutableList<String> columnNames = getColumnNames(entry.getValue());

         String join = Joiner.on(",").join(getColumnNames(entry.getValue()));
         builder.append(join).append(")");
         list.add(builder.toString());
      }
      return Joiner.on("\n\t,").join(list);
   }
       //  KEY `NAME_CITYID_UNIQUE` (`CITY_ID`,`NAME`)
   private String getIndexes(Map<String, List<Column>> uniqueIndexes) {
      List<String> list = Lists.newArrayList();

      for(Map.Entry<String, List<Column>> entry : uniqueIndexes.entrySet()) {
         StringBuilder builder = new StringBuilder();
         builder.append("key ").append(entry.getKey()).append(" (");
         ImmutableList<String> columnNames = getColumnNames(entry.getValue());

         String join = Joiner.on(",").join(getColumnNames(entry.getValue()));
         builder.append(join).append(")");
         list.add(builder.toString());
      }
      return Joiner.on("\n\t,").join(list);
   }

   private ImmutableList<String> getColumnNames(List<Column> value) {
      return FluentIterable.from(value).transform(new Function<Column, String>() {
         @Nullable
         @Override
         public String apply(Column input) {
//            return "`".concat(input.getDatabaseName()).concat("`");
            return input.getDatabaseName();
         }
      }).toList();
   }

   private String getDefaultInfo(Column column) {
        com.digitolio.jdbi.annotations.Column annotation = column.getField().getAnnotation(
                com.digitolio.jdbi.annotations.Column.class);
        String defaultValue = "";
        if (annotation != null) {
            if (annotation.defaultValue().equals(com.digitolio.jdbi.annotations.Column.defaultValueConstant)) {
                defaultValue = "";
            } else {
                defaultValue = "default '" +annotation.defaultValue() + "'";
            }
        }
        return defaultValue;
    }

    private String getAutoGeneratedInfo(Column column) {
        Field field = column.getField();
        PK annotation = field.getAnnotation(PK.class);
        if (annotation != null && annotation.autoIncrement()) {
            return " auto_increment";
        } else {
            return "";
        }
    }

    private String getNullInfo(Column column) {
        com.digitolio.jdbi.annotations.Column annotation = column.getField().getAnnotation(
                com.digitolio.jdbi.annotations.Column.class);
        boolean nullable = false;
        if (annotation != null) {
            nullable = annotation.nullable();
        }
        if (nullable) {
            return " null ";
        } else {
            return " not null ";
        }
    }

    private String getDbType(Column column) {
        Class<?> clazz = column.getField().getType();
        if (Integer.class.isAssignableFrom(clazz)) {
            return "int";
        } else if (Long.class.isAssignableFrom(clazz)) {
            return "bigint";
        } else if (Double.class.isAssignableFrom(clazz)) {
                return "double";
        } else if (String.class.isAssignableFrom(clazz)) {
            return column.getLength() == -1 ? "varchar(128)" : "varchar("+ column.getLength() +")";
        } else if (Date.class.isAssignableFrom(clazz)) {
            return "datetime";
        } else if (Enum.class.isAssignableFrom(clazz)) {
            return "varchar(128)";
        }else if (Boolean.class.isAssignableFrom(clazz)) {
            return "boolean";
        }

        return "doktor bu ne";

    }

/*
    drop table shopping_cart_item if exists;
    create table shopping_cart_item (
       order_id       int        not null
       ,user_id   int not null
       ,item_count   int not null
       ,item_price   int not null
       ,primary key(user_id, order_id)
    );

    drop table product_order if exists;
    create table product_order (
       order_id    int        not null  primary key auto_increment
       ,user_id   int not null
       ,order_type   varchar(20) not null
       ,order_time datetime not null
       ,process_time datetime not null
       ,activate_time datetime not null
       ,refund_time datetime not null
    );
*/

}
